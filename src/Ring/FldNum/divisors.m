////////////////////////////////////////////////////////////////////////
//                                                                    //
//                       Divisors of Number Fields                    //
//                              David Kohel                           //
//                         Created November 2001                      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic Divisor(x::FldNumElt) -> DivNumElt
    {The fractional ideal generated by x as a divisor.}
    // N.B. The computation of the maximal order is invoked.
    K := Parent(x);
    O := MaximalOrder(K);
    return Divisor(O*x);
end intrinsic;

intrinsic Decomposition(K::FldRat,p::RngIntElt) -> Infty
    {}
    require IsPrime(p) : "Argument 2 must be a prime element.";
    return [ <Abs(p),1> ];
end intrinsic;

intrinsic Decomposition(K::FldRat,p::Infty) -> Infty
    {The (trivial) decomposition of p into places of the rationals.}
    return [ <p,1> ];
end intrinsic;

intrinsic Valuation(I::RngOrdFracIdl,p::PlcNumElt) -> RngIntElt
    {}
    return Min([Valuation(x,p) : x in Generators(I)]);
end intrinsic;

intrinsic Valuation(I::RngOrdIdl,p::PlcNumElt) -> RngIntElt
    {The valuation of the ideal I at a finite place p.}
    return Min([Valuation(x,p) : x in Generators(I)]);
end intrinsic;

intrinsic InfinitePlaces(K::FldRat) -> SeqEnum
    {}
    return [ Infinity() ];
end intrinsic;

/*
// Signature now exists for FldAlg:

intrinsic InfinitePlaces(K::FldNum) -> SeqEnum
    {The infinite places of the number field K.}
    return [ p[1] : p in Decomposition(K,Infinity()) ];
end intrinsic;
*/

intrinsic Evaluate(x::FldRatElt,p::PlcNumElt : Precision := 0) -> RngElt
    {}
    K := NumberField(p);
    bool, pp := IsFinite(p);
    if not bool then
	// Can't get the precision, so this will persist
	if Precision ne 0 then SetKantPrecision(K,Precision); end if;
	return Conjugate(K!x,1); // all images are equal
    end if;
    R, m := ResidueClassField(pp);
    if x eq 0 then return m(x); end if;
    require Valuation(x,p) ge 0 :
        "Argument must have non-negative valuation.";
    return m(x);
end intrinsic;

/*
// Signature now exists for FldNumElt:

intrinsic Evaluate(x::FldNumElt,p::PlcNumElt : Precision := 0) -> RngElt
    {The evaluation of x in the residue class field of p.}
    K := Parent(x);
    require Type(BaseField(K)) eq FldRat :
        "Parent of argument 1 must be an absolute extension";
    bool, x := IsCoercible(NumberField(p),x);
    require bool :
        "Argument 1 must be an element of the number field of argument 2.";
    bool, i := IsInfinite(p);
    if bool then
	if Precision ne 0 then
	    require Precision ge 4 :
	        "Parameter Precision must be at least 4.";
  	    SetKantPrecision(K,Precision);
	end if;
	return Conjugate(x,i);
    end if;
    K := Parent(x);
    bool, pp := IsFinite(p);
    R, m := ResidueClassField(pp);
    if x eq 0 then return m(x); end if;
    require Valuation(x,p) ge 0 :
        "Argument must have non-negative valuation.";
    return m(x);
end intrinsic;
*/
