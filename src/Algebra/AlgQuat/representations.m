//////////////////////////////////////////////////////////////////////////////
//                                                                          // 
//        Matrix Representations and Splitting Fields for Quaternions       //
//  Copyright (C) 2002 David Kohel <kohel@maths.usyd.edu>                   //
//                                                                          //
//  Distributed under the terms of the GNU General Public License (GPL)     //
//                  http://www.gnu.org/licenses/                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

intrinsic IsSplittingField(A::AlgQuat,K::FldQuad) -> BoolElt
    {Returns true if and only if K is a splitting field for A.}
    require Type(BaseField(A)) eq FldRat :
        "Argument 1 must be defined over the rationals.";
    D := Discriminant(K); 
    return &and[ KroneckerSymbol(D,p) ne 1 : p in RamifiedPrimes(A) ];
end intrinsic;

/*
intrinsic MatrixRepresentation(R::AlgQuatOrd,K::FldQuad) -> BoolElt
    {}
    A := QuaternionAlgebra(R);
    require IsSplittingField(A,K) :
	"Argument 2 must be a splitting field for argument 1.";
    M := GramMatrix(R);
    P3<x,y,z> := PolynomialRing(K,3);
    return &+[ M[i,j]*P4.i*P4.j : i, j in [1..4] ]/2;
end intrinsic;
*/

intrinsic MatrixRepresentation(A::AlgQuat) -> Map
    {Returns a 2-dimensional matrix representation over the splitting
    field generated by the first non-central basis element.}
    require Type(BaseField(A)) eq FldRat :
       "Argument must be defined over the rationals.";
    f := CharacteristicPolynomial(A.1);
    K := NumberField(f);
    MatK := MatrixAlgebra(K,2);
    i := A.1; j := A.2; k := A.3;
    B := [ 1, i, j, i*j ];
    t1 := Trace(i)/2;
    t2 := Trace(j)/2; n2 := t2^2-Norm(j);
    M0 := MatK!1;
    M1 := MatK![ K.1, 0, 0, t1-K.1 ];
    M2 := MatK![ t2, 1, n2, t2 ];
    M := Matrix(4,4,&cat[ Eltseq(x) : x in B ]);
    c := Eltseq(A.3);
    M3 := c[1]*M0 + c[2]*M1 + (c[3] + c[4]*M1)*M2;  
    MatGens := [ M0, M1, M2, M3 ];
    return hom< A -> MatK | x :->
        &+[ c[i]*MatGens[i] : i in [1..4] ]
            where c := Eltseq(x) >;
end intrinsic;

intrinsic MatrixRepresentation(R::AlgQuatOrd) -> Map
    {Returns a 2-dimensional matrix representation over the
    splitting field generated by the first non-central basis
    element of the quaternion algebra containing R.}
    A := QuaternionAlgebra(R);
    require Type(BaseField(A)) eq FldRat :
       "Argument must be defined over the integers.";
    f := MatrixRepresentation(A);
    MatK := Codomain(f);
    B := Basis(R);
    MatGens := [ f(A!x) : x in B ];
    return hom< R -> MatK | x :->
    &+[ c[i]*MatGens[i] : i in [1..4] ] where c := Eltseq(x) >;
end intrinsic;

function pSplittingElement(R,p)
    FF := FiniteField(p);
    ZZ := IntegerRing();
    for i in [1..3] do
	x := R.i;
	D := ZZ!(Trace(x)^2-4*Norm(x));
	if KroneckerSymbol(D,p) eq 1 then
	    return x;
	end if;
    end for;
    M := GramMatrix(R);
    D := Matrix(3,[ FF | M[1,1]*M[i,j]-M[1,i]*M[1,j] : i, j in [2..4] ]);
    PP := ProjectiveSpace(FF,2);
    f := &+[ D[i,j]*PP.i*PP.j : i, j in [1..3] ]; 
    P := RationalPoint(Conic(PP,f));
    x := R!([0] cat [ ZZ!a : a in Eltseq(P) ]);
    return x;
end function;

function pZeroDivisor(R,K)
    if Type(K) eq FldFin then
	p := Characteristic(K);
	F := K;
    else
	p := ResidueCharacteristic(K);
	F := ResidueClassField(K);
    end if;
    x := pSplittingElement(R,p);
    f := CharacteristicPolynomial(x);
    a := Integers()!Roots(PolynomialRing(F)!f)[1][1];
    if Type(K) eq FldFin then
	return x-a;
    end if;
    a := Integers()!HenselLift(PolynomialRing(K)!f,K!a);
    return x-a;
end function;

intrinsic MatrixRepresentation(R::AlgQuatOrd,K::FldFin) -> Map
    {Finds and returns a matrix representation over K.}
    require Type(BaseRing(R)) eq RngInt :
	"Argument 1 must be defined over the integers.";
    require Degree(K) eq 1 :
	"Argument 2 must be a prime field.";
    require K!Discriminant(R) ne 0:
	"Discriminant of argument 1 must not be zero in argument 2.";
    e := pZeroDivisor(R,K);
    M := RModule(K,4);
    N := sub< M | [ Eltseq(x*e) : x in Basis(R) ] >;
    A := BaseExtend(AssociativeAlgebra(R),K);
    B := [ A!Eltseq(M!N.j) : j in [1,2] ];
    ImgMats := [ Transpose(Matrix([
	Coordinates(N,N!M!Eltseq(x*y)) : y in B ])) : x in Basis(A) ];
    return hom< R -> MatrixAlgebra(K,2) | x :->
        &+[ c[i]*ImgMats[i] : i in [1..4] ] where c := Eltseq(x) >;
end intrinsic;

function PivotEchelonisation(N)
    M := BasisMatrix(N);
    m := Nrows(M); n := Ncols(M);
    if m eq 2 then
	return iso< N->N | x :-> x, y :-> y >;
    end if;
    pi := [];
    for i in [1..m] do
	v := Min([ [Valuation(M[i,j]),j] : j in [1..n] | j notin pi ]);
	Append(~pi,v[2]);
    end for;
    T := RMatrixSpace(BaseRing(N),m, n)!0;
    for i in [1..m] do
	T[i,pi[i]] := 1;
    end for;
    // print "T:"; T;
    U := T^-1;
    A := RSpace(BaseRing(N),n); 
    P := sub< A | [ [ M[i,pi[j]] : j in [1..n] ] : i in [1..m] ] >;
    return iso< N->P | x :-> x*T, y :-> y*U >;
end function;

intrinsic MatrixRepresentation(R::AlgQuatOrd,K::RngPadRes) -> Map
    {Finds and returns a matrix representation over K.}
    require Type(BaseRing(R)) eq RngInt :
	"Argument 1 must be defined over the integers.";
    require Valuation(K!Discriminant(R)) eq 0:
	"Discriminant of argument 1 must be a unit in argument 2.";
    p := ResidueCharacteristic(K);
    e := pZeroDivisor(R,K);
    f := MinimalPolynomial(e);
    q := #K;
    M := RSpace(K,4);
    N := sub< M | [ M!Eltseq(x*e) : x in Basis(R) ] >;
    phi := PivotEchelonisation(N);
    P := Codomain(phi);
    // print "Basis(P):"; [ M!(v@@phi) : v in Basis(P) ];
    // print "Generators(P):", Generators(P);
    A := BaseExtend(AssociativeAlgebra(R),K);
    B := [ A!Eltseq(M!(v@@phi)) : v in Basis(P) ];
    /*
    for x in Basis(A) do
	"IN M!:"; [ M!Eltseq(x*y) : y in B ];
	"IN N?:"; [ M!Eltseq(x*y) in N : y in B ];
	"COORDS:"; Matrix([ Coordinates(N,N!M!Eltseq(x*y)) : y in B ]);
    end for;
    */
    ImgMats := [ Transpose(Matrix(K,[
	Coordinates(P,phi(N!M!Eltseq(x*y))) : y in B ])) : x in Basis(A) ];
    print ImgMats;
    return hom< R -> MatrixAlgebra(K,2) | x :->
        &+[ c[i]*ImgMats[i] : i in [1..4] ] where c := Eltseq(x) >;
end intrinsic;
