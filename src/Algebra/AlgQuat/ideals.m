//////////////////////////////////////////////////////////////////////////////
//                                                                          // 
//                    Ideal and Order Constructors                          //
//  Copyright (C) 2000 David Kohel <kohel@maths.usyd.edu>                   //
//                                                                          //
//  Distributed under the terms of the GNU General Public License (GPL)     //
//                  http://www.gnu.org/licenses/                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

intrinsic ILO(I::AlgQuatOrd) -> AlgQuatOrd
    {}
    // internal left order function - called from LeftOrder 
    n := Norm(I);
    B := [QuaternionAlgebra(I)!x : x in Basis(I)];
    L := QuaternionOrder([x*Conjugate(y)/n : x, y in B]);
    return L;
end intrinsic;
 
intrinsic IRO(I::AlgQuatOrd) -> AlgQuatOrd
    {}
    // internal right order function - called from RightOrder 
    n := Norm(I);
    B := [QuaternionAlgebra(I)!x : x in Basis(I)];
    R := QuaternionOrder([Conjugate(x)*y/n : x, y in B]);
    return R;
end intrinsic;

intrinsic LeftIdeal(A::AlgQuatOrd,S::SeqEnum) -> AlgQuatOrdIdl
    {Left ideal of A with generator sequence S.}

    K := QuaternionAlgebra(A);
    U := Universe(S); 
    if Type(U) eq RngInt or U cmpeq BaseRing(A) then
	S := [ K!x : x in S ];
    elif Type(U) cmpeq AlgQuatOrd then
	require &and [ IsCoercible(A,x) : x in S ] :
	    "Incompatible ring and sequence universe.";
    else 
	require K cmpeq U : "Incompatible ring and sequence universe.";
	require &and [ IsCoercible(A,x) : x in S ] :
	    "Elements of argument 2 do not coerce into argument 1.";
    end if;
    return lideal< A | S >;
end intrinsic;

intrinsic RightIdeal(A::AlgQuatOrd,S::SeqEnum) -> AlgQuatOrdIdl
    {Right ideal of A with generator sequence S.}

    K := QuaternionAlgebra(A);
    U := Universe(S); 
    if Type(U) eq RngInt or U cmpeq BaseRing(A) then
	S := [ A!x : x in S ];
    elif Type(U) cmpeq AlgQuatOrd then
	require &and[ IsCoercible(A,x) : x in S ] :
	    "Incompatible ring and sequence universe.";
    else 
	require K cmpeq U : "Incompatible ring and sequence universe.";
	require &and [ IsCoercible(A,x) : x in S ] :
	    "Elements of argument 2 do not coerce into argument 1.";
    end if;
    return rideal< A | S >;
end intrinsic;

intrinsic CommutatorIdeal(A::AlgQuatOrd) -> AlgQuatOrdIdl
    {The ideal of A generated by elements of the form x*y - y*x.}
    return ideal< A | [ x*y - y*x : x,y  in Basis(A) ]>;
end intrinsic;

intrinsic Different(A::AlgQuatOrd) -> AlgQuatOrd
    {The ideal of A generated by elements of the form x*y - y*x.}
    return CommutatorIdeal(A);
end intrinsic;

intrinsic PrimeIdeal(A::AlgQuatOrd,p::RngIntElt) -> AlgQuatOrdIdl
    {The unique two-sided ideal over p.}
    require Type(BaseRing(A)) eq RngInt: 
	"Argument 1 must be an order over the integers";
    require IsPrime(p): "Argument 2 must be a prime.";
    if IsRamified(QuaternionAlgebra(A),p) then
	return ideal< A | [ A ! p ] cat [ x*y - y*x : x,y  in Basis(A) ]>;
    else
	return ideal< A | p >;
    end if;
end intrinsic;

intrinsic Coordinates(I::AlgQuatOrdIdl[RngInt],x::AlgQuatOrdElt) -> SeqEnum
    {The coordinates of x in terms of the basis of I.}
    A := QuaternionAlgebra(Order(I));
    bool, x := IsCoercible(A,x);
    require bool : 
        "Argument 2 must be an element of the quaternion algebra of argument 1.";
    return Coordinates(I,x);
end intrinsic;

intrinsic Coordinates(I::AlgQuatOrdIdl[RngInt],x::AlgQuatElt) -> SeqEnum
    {The coordinates of x in terms of the basis of I.}
    A := QuaternionAlgebra(Order(I));
    require A cmpeq Parent(x) :
        "Argument 2 must be an element of the quaternion algebra of argument 1.";
    U := Matrix([ Eltseq(y) : y in Basis(I) ]);
    v := Vector(Eltseq(x))*U^-1;
    bool, v := CanChangeUniverse(Eltseq(v),IntegerRing());
    require bool : "Argument 2 is not in argument 1.";
    return v;
end intrinsic;
