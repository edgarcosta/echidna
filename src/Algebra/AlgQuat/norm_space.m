//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//               Norm Spaces and Modules of Quaternions                     //
//  Copyright (C) 2002 David Kohel <kohel@maths.usyd.edu>                   //
//                                                                          //
//  Distributed under the terms of the GNU General Public License (GPL)     //
//                  http://www.gnu.org/licenses/                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

intrinsic NormSpace(A::AlgQuat) -> ModFld, Map
    {The inner product space of A with respect to the norm.} 
   if not assigned A`NormSpace then
       F := BaseField(A);
       A`NormSpace := RSpace(F,4,MatrixAlgebra(F,4) ! 
	   [ Norm(x+y) - Norm(x) - Norm(y) : x, y in Basis(A) ] ); 
   end if;
   V := A`NormSpace;
   return V, hom< V->A | x :-> V!Eltseq(x) >;
end intrinsic;

intrinsic NormSpace(B::[AlgQuatElt]) -> ModTupFld
    {The inner product subspace with respect to the norm generated by the sequence B.} 
    V := NormSpace(Universe(B));
    return sub< V | [ V!Eltseq(x) : x in B ] >;
end intrinsic;

intrinsic NormSpace(O::AlgQuatOrd) -> ModTupRng, Map
    {The inner product module of O with respect to the norm.} 
    if not assigned O`NormSpace then
	R := BaseRing(O);
	O`NormSpace := RSpace( R, 4, [ Norm(x+y) - Norm(x) - Norm(y) : x, y in Basis(O) ] ); 
    end if;
    M := O`NormSpace;
    return M, hom< O -> M | x :-> M!Eltseq(x) >;
end intrinsic;
 
intrinsic NormSpace(I::AlgQuatOrdIdl) -> ModTupRng, Map
    {The inner product module of I with respect to the norm.} 
    /* Stupidly, we can't have attributes or elements of ideals). */
    B := Basis(I);
    O := Order(I);
    R := BaseRing(O);
    K := BaseField(QuaternionAlgebra(O));
    U := Matrix(K,[ Eltseq(O!x) : x in B ])^-1;
    V := VectorSpace(K,4);
    M := RSpace( R, 4, [ Norm(x+y) - Norm(x) - Norm(y) : x, y in B ] ); 
    function NormSpaceImage(x)
        error if x notin I, "Element is not in domain.";
        v := V!Eltseq(O!x)*U;
        return M!Eltseq(v);
    end function;
    return M, NormSpaceImage;
end intrinsic;
 
intrinsic NormalizedNormSpace(I::AlgQuatOrdIdl) -> ModTupRng, Map
    {The inner product module of I with respect to the normalized norm.} 
    /* Stupidly, we can't have attributes or elements of ideals). */
    B := Basis(I);
    O := Order(I);
    R := BaseRing(O);
    K := BaseField(QuaternionAlgebra(O));
    U := Matrix(K,[ Eltseq(O!x) : x in B ])^-1;
    V := VectorSpace(K,4);
    NrmI := Norm(I);
    M := RSpace( R, 4, [ K!(Norm(x+y) - Norm(x) - Norm(y))/NrmI : x, y in B ] ); 
    function NormSpaceImage(x)
        error if x notin I, "Element is not in domain.";
        v := V!Eltseq(O!x)*U;
        return M!Eltseq(v);
    end function;
    return M, NormSpaceImage;
end intrinsic;
 
intrinsic NormModule(O::AlgQuatOrd) -> ModTupRng
    {The inner product space of O with respect to the norm.} 
    return NormSpace(O);
end intrinsic;

intrinsic NormModule(I::AlgQuatOrdIdl) -> ModTupRng
    {The inner product space of I with respect to the norm.} 
    return NormSpace(I);
end intrinsic;

intrinsic NormalizedNormModule(O::AlgQuatOrd) -> ModTupRng
    {The inner product space of O with respect to the norm.} 
    return NormalizedNormSpace(O);
end intrinsic;

intrinsic NormalizedNormModule(I::AlgQuatOrdIdl) -> ModTupRng
    {The inner product space of I with respect to the normalized norm.} 
    return NormalizedNormSpace(I);
end intrinsic;

intrinsic DiscriminantSpace(O::AlgQuatOrd) -> ModTupRng, Map
    {The inner product module of O/Z with respect to the discriminant.} 
    B := ReducedBasis(O);
    if B[1] ne O!1 then
        // The first basis element might not be 1!
        B := [ u*x : x in B ] where u := B[1]^-1;
    end if;
    R := BaseRing(O);
    A := Matrix([ [ Norm(x+y)-Norm(x)-Norm(y) : x in B ] : y in B ]);
    D := Matrix(R,[ [ A[1,1]*A[i,j] - A[1,i]*A[1,j] : i in [2..4] ] :  j in [2..4] ]);
    M := RSpace(R,3,D);
    U := Matrix([ Eltseq(x) : x in B ])^-1;
    return M, hom< O -> M | x :-> M!(Eltseq(Vector(Eltseq(x))*U)[[2..4]]) >;
end intrinsic;

intrinsic DiscriminantModule(O::AlgQuatOrd) -> ModTupRng
    {The inner product module of O/Z with respect to the discriminant.}
    return DiscriminantSpace(O);
end intrinsic;

intrinsic DualDiscriminantModule(O::AlgQuatOrd[RngInt]) -> ModTupRng
    {The inner product module of O/Z with respect to the discriminant.}
    D := DiscriminantModule(O);
    N := Discriminant(QuaternionAlgebra(O));
    R := IsPrime(N) select FiniteField(N) else ResidueClassRing(N);
    MatR := MatrixAlgebra(R,3);
    A := GramMatrix(D);
    V := Kernel(MatR!A);
    L := LatticeWithGram(A);
    L_dual := LLL(sub< L | [ L!u : u in Basis(V) ] cat [ N*v : v in Basis(L) ] >);
    MatQ := MatrixAlgebra(RationalField(),3);
    MatZ := MatrixAlgebra(IntegerRing(),3);
    A_dual := MatZ!(1/N*MatQ!GramMatrix(L_dual));
    return RSpace(BaseRing(O),3,A_dual);
end intrinsic;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                               Basis                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

intrinsic BasisMatrix(A::AlgQuatOrd) -> AlgMatElt
   {}
   K := QuaternionAlgebra(A);
   return Matrix(4,4,&cat[ Eltseq(K!x) : x in Basis(A) ]);
end intrinsic;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                           Basis Reduction                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

intrinsic ReducedBasis(A::AlgQuatOrd) -> SeqEnum
   {A Minkowski-reduced basis for A, unique up to isomorphism.}
   require Type(BaseRing(A)) eq RngInt :
      "Base ring must be the integer ring.";
   require IsDefinite(QuaternionAlgebra(A)) : 
      "Parent algebra is not definite.";
   if not assigned A`ReducedMatrix then
      M, U := MinkowskiGramReduction(GramMatrix(A) : Canonical := true);
      u := A!U[1]; 
      if Norm(u) eq 1 and Eltseq(U[1]) ne [1,0,0,0] then
         u := Conjugate(u);
         B := [ u*(A!U[i]) : i in [1..4] ];
         U := Matrix(4,4,[ Eltseq(x) : x in B ]);         
      end if;
      A`ReducedGram := M;
      A`ReducedMatrix := U;
   end if;
   return [ A!Eltseq(A`ReducedMatrix[i]) : i in [1..4] ];
end intrinsic; 

intrinsic ReducedGramMatrix(A::AlgQuatOrd) -> AlgMatElt
   {A canonical Minkowski-reduced Gram matrix for the norm 
   inner product on A.}
   require Type(BaseRing(A)) eq RngInt :
      "Base ring must be the integer ring.";
   require IsDefinite(QuaternionAlgebra(A)) : 
      "Parent algebra is not definite.";
   if not assigned A`ReducedGram then
      M, U := MinkowskiGramReduction(GramMatrix(A) : Canonical := true);
      A`ReducedGram := M;
      A`ReducedMatrix := U;
   end if;
   return A`ReducedGram;
end intrinsic;

intrinsic ReducedGramMatrix(I::AlgQuatOrdIdl) -> AlgMatElt
    {}
    A := Order(I);
    require Type(BaseRing(A)) eq RngInt :
      "Base ring must be the integer ring.";
   require IsDefinite(QuaternionAlgebra(A)) : 
      "Parent algebra is not definite.";
    return MinkowskiGramReduction(GramMatrix(I) : Canonical := true);
end intrinsic;

////////////////////////////////////////////////////////////////////////////////////
//                        Norms and Gram matrices for ideals                      //
////////////////////////////////////////////////////////////////////////////////////

intrinsic Norm(I::AlgQuatOrdIdl) -> RngElt
    {The norm of the ideal I.}
    bool, r := IsSquare(Abs(Determinant(GramMatrix(I))));
    assert bool;
    r /:= Discriminant(Order(I));
    bool, r := IsSquare(Abs(r));
    assert bool;
    return Abs(r);
end intrinsic;

intrinsic GramMatrix(I::AlgQuatOrdIdl) -> AlgMatElt
    {}
    B := Basis(I);
    return Matrix([ [ Norm(x + y) - Norm(x) - Norm(y) : x in B] : y in B]);
end intrinsic;

