////////////////////////////////////////////////////////////////////
//                                                                //
//                         Abelian Monoids                        //
//                           David Kohel                          //
//                          February 2000                         //
//                                                                //
////////////////////////////////////////////////////////////////////

forward BuildRelations;

////////////////////////////////////////////////////////////////////
//                                                                //
//                      Attribute declarations                    //
//                                                                //
////////////////////////////////////////////////////////////////////

declare type MonAb[MonAbElt];

declare attributes MonAb:
   AmbientMonoid,
   KernelBasis,
   CoveringMonoid,
   PolynomialRing,
   Generators,
   Representations,
   RepresentationElements,
   DefiningRelations, // User specified defining relations.
   GroebnerRelations, // Groeber relations in polynomial ring.
   GroupLaw, // "Multiplicative" or "Additive"
   Printing, // "Generator" or "Vector" (Additive model only)
   Labels;

declare attributes MonAbElt:
   Parent,
   Element;

////////////////////////////////////////////////////////////////////
//                                                                //
//                       Creation functions                       //
//                                                                //
////////////////////////////////////////////////////////////////////

intrinsic FreeAbelianMonoid(n::RngIntElt) -> MonAb
   {Free abelian monoid of rank n.}
   M := New(MonAb);
   P := PolynomialRing(GF(2),n);
   M`PolynomialRing := P;
   M`Generators := [ P.i : i in [1..n] ];
   M`DefiningRelations := [ P | ];
   M`GroebnerRelations := [ P | ];
   M`GroupLaw := "Multiplicative";
   M`Printing := "Generator";  // only used for "Additive" group law
   M`Labels := [ "$." cat IntegerToString(i) : i in [1..n] ];
   return M;
end intrinsic;

intrinsic AbelianMonoid(S::[MonAbElt]) -> MonAb
   {The submonoid generated by S}
   M := Universe(S);
   S := [ x : x in S | x ne M!0 ];
   R := [ x`Element : x in S ];
   P := Universe(R);
   if { x : x in R } eq { P.i : i in [1..Rank(P)] } then
      return M;
   end if;
   N := New(MonAb);
   if assigned M`AmbientMonoid then
      N`AmbientMonoid := M`AmbientMonoid;
   else
      N`AmbientMonoid := M;
   end if;
   N`Generators := R;
   m := #S; n := Ngens(M);
   P := PolynomialRing(GF(2),m);
   N`PolynomialRing := P;
   // Set covering monoid...
   C := New(MonAb);
   C`PolynomialRing := P;
   C`Generators := [ P.i : i in [1..m] ];
   C`DefiningRelations := [ P | ];
   C`GroebnerRelations := [ P | ];
   C`GroupLaw := M`GroupLaw;
   C`Printing := M`Printing;
   C`Labels := [ "$." cat IntegerToString(i) : i in [1..n] ];
   N`CoveringMonoid := C;
   N`Printing := M`Printing;
   N`GroupLaw := M`GroupLaw;
   M`Labels := [ "$." cat IntegerToString(i) : i in [1..#R] ];
   BuildRelations(N,S);
   return N;
end intrinsic;

procedure BuildRelations(N,S)
   // Find defining relations...
   P := N`PolynomialRing;
   A := N`AmbientMonoid;
   C := N`CoveringMonoid;
   N`RepresentationElements := [ A | ];
   N`Representations := [ Parent([ C | ]) | ];
   n := Ngens(N); 
   r := Ngens(A);
   B := Basis(Kernel(Matrix(n, r, &cat [ Eltseq(x) : x in S ])));
   N`KernelBasis := B;
   B cat:= [ B[i] - B[j] : i, j in [1..#B] | i lt j ];
   rels := [ P | &*[ P | P.i^v[i] : i in [1..n] | v[i] gt 0 ]
         - &*[ P | P.i^-v[i] : i in [1..n] | v[i] lt 0 ] : v in B ];
   if r eq 1 then
      gens := Sort(&cat[ Eltseq(x) : x in S ]); 
      if n eq 1 then
         n1 := n+1;
         n2 := 2;
      else  
         n1 := gens[n-1];
         n2 := gens[n];
      end if;
      c := GCD(gens);
      for j in [1..((n1-1)*(n2-1)) div c] do 
         reps := Representations(N,A![c*j]);
         if #reps ge 2 then
   	    e1 := Eltseq(reps[1]);
            for k in [2..#reps] do
      	       e2 := Eltseq(reps[k]);
               Append(~rels, &*[ P | P.i^e1[i] : i in [1..n] ]
                           - &*[ P | P.i^e2[i] : i in [1..n] ] );
            end for;               
         end if;    
      end for;
   end if;
   N`GroebnerRelations := GroebnerBasis(rels);
   N`DefiningRelations := N`GroebnerRelations;
end procedure;

intrinsic Quotient(R::[MonAbElt]) -> MonAb
   {The quotient monoid by the relations R}
   return Quotient(R,[ Universe(R)!0 : i in [1..#R] ]);
end intrinsic;

intrinsic Quotient(L::[MonAbElt],R::[MonAbElt]) -> MonAb
   {The quotient monoid by the relations L[i] = R[i]}
   M := Universe(L);
   require Universe(R) eq M : "Arguments have incompatible universes";
   require #L eq #R : "Arguments have different lengths";
   if #L eq 0 then 
      return M;
   end if;
   N := New(MonAb);
   if assigned M`AmbientMonoid then
      N`AmbientMonoid := M`AmbientMonoid; 
   else
      N`AmbientMonoid := M;
   end if;
   P := M`PolynomialRing;
   N`PolynomialRing := P;
   N`DefiningRelations := M`DefiningRelations cat 
      [ L[i]`Element - R[i]`Element : i in [1..#L] ];
   R := GroebnerBasis( M`GroebnerRelations 
      cat [ L[i]`Element - R[i]`Element : i in [1..#L] ] );
   N`GroebnerRelations := R;
   N`Generators := [ m : m in {@ 
      NormalForm(m0,R) : m0 in M`Generators @} | m ne 1 ];
   N`GroupLaw := M`GroupLaw;
   N`Printing := M`Printing;
   N`Labels := [ "$." cat IntegerToString(i) 
      : i in [1..#N`Generators] ];
   return N;
end intrinsic;

intrinsic AssignNames(~M::MonAb, S::[MonStgElt])
   {Assign names to generating elements.}
   require Ngens(M) eq #S: 
      "The length of argument 2 must equal the number of generators"; 
   P := M`PolynomialRing;
   AssignNames(~P,S);
   M`Labels := S;
end intrinsic;

intrinsic Name(M::MonAb,i::RngIntElt) -> MonAbElt
   {The ith generator.}
   require i ge 1 and i le Ngens(M): "Illegal index.";
   return M.i;
end intrinsic;

intrinsic '.'(M::MonAb,i::RngIntElt) -> MonAbElt
   {The ith generator.}
   require i ge 1 and i le Ngens(M) : "Illegal index.";
   return M ! M`PolynomialRing.i;
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
//                         Coercions                              //
//                                                                //
////////////////////////////////////////////////////////////////////

function initMonAbElt(M,m)
   x := New(MonAbElt);
   x`Parent := M;
   x`Element := NormalForm(m,M`GroebnerRelations);
   return x;
end function;

intrinsic IsCoercible(M::MonAb,S::.) -> BoolElt, MonAbElt
   {}
   if Type(S) eq MonAbElt then
      if Parent(S) eq M then
         return true, S;
      elif M eq AmbientMonoid(Parent(S)) then
         N := Parent(S);
         g := N`Generators;
         c := Eltseq(S);
         m := &*[ g[i]^c[i] : i in [1..Ngens(N)] ];
         return true, initMonAbElt(M,m);
      elif CoveringMonoid(M) eq Parent(S) then
         return true, initMonAbElt(M,S`Element);
      elif AmbientMonoid(Parent(S)) eq AmbientMonoid(M) then
         return false, "No test for monoid membership";
      end if;
   elif Type(S) eq RngIntElt and S eq 0 then
      return true, initMonAbElt(M,Universe(M`DefiningRelations)!1);   
   elif Type(S) eq SeqEnum and #S eq Ngens(M) and 
      Type(Universe(S)) eq RngInt then
      m := &*[ Universe(M`DefiningRelations).i^S[i] 
         : i in [1..Ngens(M)] ];
      return true, initMonAbElt(M,m);   
   elif Type(S) eq RngMPolElt then
      if Parent(S) cmpeq Universe(M`DefiningRelations) and 
         #Monomials(S) eq 1 then 
         return true, initMonAbElt(M,S);
      end if;
   end if;
   return false, "Illegal coercion.";
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
//                        Printing                                //
//                                                                //
////////////////////////////////////////////////////////////////////

intrinsic SetPrinting(M::MonAb,S::MonStgElt) 
   {Set printing to S, where S is "Vector" or "Generator".}
   require S in {"Vector","Generator"} : 
      "Argument 2 must take value \"Vector\" or \"Generator\"";
   M`Printing := S;
   if assigned M`CoveringMonoid then
      M`CoveringMonoid`Printing := S;
   end if;
end intrinsic;

intrinsic SetGroupLaw(M::MonAb,S::MonStgElt) 
   {Set group law to S, where S is "Additive" or "Multiplicative".}
   require S in {"Additive","Multiplicative"} : 
      "Argument 2 must take value \"Additive\" or \"Multiplicative\".";
   M`GroupLaw := S;
   if assigned M`CoveringMonoid then
      M`CoveringMonoid`GroupLaw := S;
   end if;
end intrinsic;

intrinsic Print(M::MonAb, level::MonStgElt)
   {}
   A := AmbientMonoid(M); 
   if M eq AmbientMonoid(M) and IsFull(M) then
      if Ngens(M) eq 1 then
         printf "Free abelian monoid on 1 generator";
      else
         printf "Free abelian monoid on %o generators", Ngens(M);
      end if;
   elif #M`DefiningRelations eq 0 then
      printf "Abelian monoid on generators \n%o\n" * 
         "and no relations", [ M.i : i in [1..Ngens(M)] ];  
   else
      printf "Abelian monoid on generators \n%o \nand relations \n%o", 
       [ M.i : i in [1..Ngens(M)] ],  
       DefiningRelations(M);
   end if;
end intrinsic;

intrinsic Print(x::MonAbElt, level::MonStgElt)
   {}
   M := Parent(x);
   A := AmbientMonoid(M);
   m := x`Element;
   if M`GroupLaw eq "Multiplicative" then
      printf "%o", m;
      return;
   end if;
   if M`Printing eq "Vector" then
      n := Rank(Parent(m));
      printf "(";
      for i in [1..n-1] do
         printf IntegerToString(Degree(m,i)) cat ", ";
      end for;
      printf IntegerToString(Degree(m,n)) cat ")";
   elif M`Printing eq "Generator" then
      n := Ngens(M);
      if x eq M!0 then
         printf "0"; 
         return;
      end if;
      plus := "";
      for i in [1..n] do
         e := Degree(m,i);
         if e notin {0,1} then
            printf plus cat "%o*" cat M`Labels[i], e;
            plus := " + ";
         elif e eq 1 then
            printf plus cat M`Labels[i];
            plus := " + ";
         end if;
      end for;
   end if;
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
//                Membership and equality testing                 //
//                                                                //
////////////////////////////////////////////////////////////////////

intrinsic 'in'(x::., M::MonAb) -> BoolElt
   {Returns true if x is in M.}
   if Type(x) eq MonAbElt then
      return x`Parent eq M;
   end if;
   return false;
end intrinsic;

intrinsic Parent(x::MonAbElt) -> MonAb
   {}
   return x`Parent;
end intrinsic;

intrinsic 'eq' (M::MonAb,N::MonAb) -> BoolElt
   {}
   return Ngens(M) eq Ngens(N) and 
      Universe(M`DefiningRelations) cmpeq 
      Universe(N`DefiningRelations) and 
      M`GroebnerRelations eq N`GroebnerRelations;
end intrinsic;

intrinsic 'eq' (x::MonAbElt,y::MonAbElt) -> BoolElt
   {}
   return Parent(x) eq Parent(y) and x`Element eq y`Element;
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
//                    Attribute Access Functions                  //
//                                                                //
////////////////////////////////////////////////////////////////////

intrinsic NumberOfGenerators(M::MonAb) -> BoolElt
   {}
   return #M`Generators;
end intrinsic;

intrinsic Ngens(M::MonAb) -> BoolElt
   {}
   return #M`Generators;
end intrinsic;

intrinsic IsFull(M::MonAb) -> BoolElt
   {}
   return { x : x in M`Generators } eq 
          { x : x in AmbientMonoid(M)`Generators };
end intrinsic;

intrinsic Generators(M::MonAb) -> BoolElt
   {The generators for M}
   return [ M.i : i in [1..Ngens(M)] ];
end intrinsic;

intrinsic AmbientMonoid(M::MonAb) -> MonAb
   {}
   if assigned M`AmbientMonoid then
      return M`AmbientMonoid;
   end if;
   return M;
end intrinsic;

intrinsic ElementToString(x::MonAbElt) -> MonStgElt
   {The printing string of x}
   n := Ngens(Parent(x));
   m := x`Element;
   S := "(";
   for i in [1..n] do
      S cat:= IntegerToString(Degree(m,i)) cat ", ";
   end for;
   return S cat IntegerToString(Degree(m,n)) cat ")";
end intrinsic;

intrinsic CoveringMonoid(M::MonAb) -> MonAb
   {}
   if M cmpeq AmbientMonoid(M) then
      return M, hom< M -> M | x :-> x >;
   end if;
   F := M`CoveringMonoid;
   return F, hom< F -> M | x :-> M ! x`Element >;
end intrinsic;

intrinsic DefiningRelations(M::MonAb) -> SeqEnum
   {The defining of M}
   F := M`CoveringMonoid;
   return [ F!m[1] = F!m[2] where m is Monomials(rel) : rel in M`DefiningRelations ];
end intrinsic;

intrinsic GroebnerRelations(M::MonAb) -> SeqEnum
   {The unique reduction relations for M}
   F := M`CoveringMonoid;
   return [ F!m[1] = F!m[2] where m is Monomials(rel) : rel in M`GroebnerRelations ];
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
//             Functionality, arithmetic operations, etc.         //
//                                                                //
////////////////////////////////////////////////////////////////////

// For additive monoids:

intrinsic '+' (x::MonAbElt,y::MonAbElt) -> MonAbElt
   {}
   M := Parent(x);
   require Parent(y) eq M : "Element have different parents";
   require M`GroupLaw eq "Additive" : "Binary operation is \"*\".";
   return initMonAbElt(M,(x`Element)*(y`Element));
end intrinsic;

intrinsic '*' (x::MonAbElt,y::MonAbElt) -> MonAbElt
   {}
   M := Parent(x);
   require Parent(y) eq M : "Element have different parents";
   require M`GroupLaw eq "Multiplicative" : "Binary operation is \"+\".";
   return initMonAbElt(M,(x`Element)*(y`Element));
end intrinsic;

intrinsic '*' (n::RngIntElt,x::MonAbElt) -> MonAbElt
   {}
   M := Parent(x);
   R := M`GroebnerRelations;
   require M`GroupLaw eq "Additive" : "Scalar operation is \"^\".";
   return Parent(x)!NormalForm((x`Element)^n,R);
end intrinsic;

intrinsic '*' (x::MonAbElt,n::RngIntElt) -> MonAbElt
   {}
   M := Parent(x);
   R := M`GroebnerRelations;
   require M`GroupLaw eq "Additive" : "Scalar operation is \"^\".";
   return Parent(x)!NormalForm((x`Element)^n,R);
end intrinsic;

intrinsic '^' (x::MonAbElt,n::RngIntElt) -> MonAbElt
   {}
   M := Parent(x);
   R := M`GroebnerRelations;
   require M`GroupLaw eq "Multiplicative" : "Scalar operation is \"*\".";
   return Parent(x)!NormalForm((x`Element)^n,R);
end intrinsic;

// For multiplicative monoids:

intrinsic '*' (x::MonAbElt,y::MonAbElt) -> MonAbElt
   {}
   M := Parent(x);
   require Parent(y) eq M : "Element have different parents";
   require M`GroupLaw eq "Multiplicative" : "Binary operation is \"+\".";
   return initMonAbElt(M,(x`Element)*(y`Element));
end intrinsic;

intrinsic Eltseq(x::MonAbElt) -> SeqEnum
   {The sequence of coefficients of x}
   return [ Degree(x`Element,i) : i in [1..Ngens(Parent(x))] ];
end intrinsic;

intrinsic Identity(M::MonAb) -> MonAbElt
   {The identity element of M}
   return M!0;
end intrinsic;

intrinsic Zero(M::MonAb) -> MonAbElt
   {The identity element of M}
   return M!0;
end intrinsic;

////////////////////////////////////////////////////////////////////
//                                                                //
////////////////////////////////////////////////////////////////////

intrinsic Representations(M::MonAb,m::MonAbElt) -> SeqEnum
   {Assume that m is an element of the ambient monoid of M;
   returns all elements of the covering monoid of M which 
   map to m.}

   // i := Index(M`RepresentationElements,m); 
   A := AmbientMonoid(M);
   require Parent(m) eq A : "Argument 2 must be an element " *
      "of the ambient monoid of argument 1.";
   i := 0;
   if M cmpeq A then 
      // M is free, so m is the only representation of itself.
      return [ m ];
   end if;
   for j in [1..#M`RepresentationElements] do
      if m eq M`RepresentationElements[j] then 
         return M`Representations[j];
      end if; 
   end for;
   b := Vector(Eltseq(m));
   A := AmbientMonoid(M);
   F := CoveringMonoid(M);
   m := Ngens(A); 
   r := Ngens(M);
   X := Matrix(r, m, &cat [ Eltseq(A!x) : x in M`Generators ]);
   u := Solution(X,b);
   B := M`KernelBasis;
   k := #B;
   Y := Transpose(
           Matrix(k+1, r, Eltseq(u) cat &cat [ Eltseq(x) : x in B ]) );
   if k eq 0 then
      Append(~M`RepresentationElements,A![m]);
      reps := [ F!Eltseq(u) ];
      Append(~M`Representations,reps);
      return reps;
   end if;
   pts := [ RSpace(RationalField(),k) | ];
   for Ex in Subsets({1..r},r-k) do
      R := Basis(Kernel(Transpose(
              Matrix([ Y[j] : j in [1..r] | j notin Ex ] ) )));
      v := Eltseq(R[1]);
      if v[1] ne 0 then 
         Append(~pts,Vector([ v[i]/v[1] : i in [2..k+1] ]));
      end if;
   end for;
   mins := [ Ceiling(Min([ P[i] : P in pts ])) : i in [1..k] ];
   maxs := [ Floor(Max([ P[i] : P in pts ])) : i in [1..k] ];
   ints := [ [mins[i]..maxs[i]] : i in [1..k] ];
   if &*[ #I : I in ints ] eq 0 then return [ F | ]; end if;
   T := [ [] ]; 
   for i in [1..k] do
      T := [ x cat [n] : x in T, n in ints[i] ]; 
   end for;
   // T is excessively large, but we form the full set of 
   // linear combinations in this rectangle... 
   S := [ u + &+[ x[i]*B[i] : i in [1..k] ] : x in T ];
   reps := [ F | Eltseq(v) : v in S | &and[ x ge 0 : x in Eltseq(v) ] ];
   Append(~M`RepresentationElements,A![m]);
   Append(~M`Representations,reps);
   return reps;
end intrinsic;

intrinsic HasRepresentation(M::MonAb,m::MonAbElt) -> BoolElt, MonAbElt
   {}
   // This is stupid...
   R := Representations(M,m);
   if #R eq 0 then 
      return false, _; 
   else
      return true, R[1];
   end if;
end intrinsic;

