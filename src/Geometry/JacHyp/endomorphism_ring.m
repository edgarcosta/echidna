//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Copyright (C) 2006 David Kohel <kohel@maths.usyd.edu>                   //
//                                                                          //
//  Distributed under the terms of the GNU General Public License (GPL)     //
//                  http://www.gnu.org/licenses/                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Conductor of the ring ZZ[pi,pi'] and Galois action on torsion.
//////////////////////////////////////////////////////////////////////////////

declare verbose EndomorphismRing, 2;
declare attributes JacHyp:
    EndomorphismRing,
    EndomorphismRingLocalRings,
    EndomorphismRingKnownSubring,
    ConductorAbelianInvariants,
    KnownSubringConductorAbelianInvariants;

//////////////////////////////////////////////////////////////////////////////

function FrobeniusApplication(f,P,FF);
    // Apply f(pi) to P where f is a polynomial over the integers and
    // pi is the Frobenius endomorphism with respect to the field FF.
    cffs := ChangeUniverse(Eltseq(f),Integers());
    Q := Parent(P)!0;
    for c in cffs do
        if c ne 0 then Q +:= c*P; end if;
        P := Frobenius(P,FF);
    end for;
    return Q;
end function;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

intrinsic EndomorphismRingKnownSubring(J::JacHyp[FldFin] : 
    MaximalRealSubring := false) -> RngOrd, SeqEnum
    {Given a simple and ordinary Jacobian J, returns the known subring of
    the endomorphism ring.  By default will return the ring generated by
    Frobenius and Verschiebung (over Z or over the maximal order of the
    real subring if MaximalRealSubring is set to true).}

    if assigned J`EndomorphismRingKnownSubring then
        S := J`EndomorphismRingKnownSubring;
        if not assigned J`KnownSubringConductorAbelianInvariants then
            cond := ConductorAbelianInvariants(S);
            J`KnownSubringConductorAbelianInvariants := cond;
        else
            cond := J`KnownSubringConductorAbelianInvariants;
        end if;
        return S, cond;
    end if;
    FF := BaseRing(J);
    p := Characteristic(FF);
    q := #FF;
    g := Dimension(J);
    zeta := FrobeniusCharacteristicPolynomial(J);
    /* r := HasseWittInvariant(Curve(J)); */
    r := Max([ i : i in [0..g] | Coefficient(zeta,2*g-i) mod p ne 0 ]);
    require IsIrreducible(zeta) and r eq g : "Argument must be a simple ordinary Jacobian.";
    ZZ := IntegerRing();
    PZ := PolynomialRing(ZZ);
    K<pi> := NumberField(zeta);
    O := MaximalOrder(K);
    R := EquationOrder(K);
    S := sub< O | pi, q/pi >;
    if MaximalRealSubring then
        T := MaximalOrder(TotallyRealSubfield(K));
        S := sub< O | Basis(S), [ t : t in Basis(T) ] >;
    end if;
    cond := ConductorAbelianInvariants(S);
    J`EndomorphismRingKnownSubring := S;
    J`KnownSubringConductorAbelianInvariants := cond;
    return S, cond;
end intrinsic;

//////////////////////////////////////////////////////////////////////////////
// Endomorphism ring algorithm
//////////////////////////////////////////////////////////////////////////////

intrinsic EndomorphismRing(J::JacHyp[FldFin] :
    GlobalSubring := false, MaximalRealSubring := false,
    LocalRings := AssociativeArray(IntegerRing())) -> RngOrd, SeqEnum
    {Given a simple and ordinary Jacobian J, returns the endomorphism ring
    O = End(J) followed by the abelian group invariants of the group quotient
    O_K/O where O_K is the maximal order containing O.}

    if assigned J`EndomorphismRing then
        return J`EndomorphismRing, J`ConductorAbelianInvariants;
    end if;
    FF := BaseRing(J);
    g := Dimension(J);
    q := #FF;
    p := Characteristic(FF);
    deg := 2*g;
    zeta := FrobeniusCharacteristicPolynomial(J);
    /* r := HasseWittInvariant(Curve(J)); */
    r := Max([ i : i in [0..g] | Coefficient(zeta,2*g-i) mod p ne 0 ]);
    require IsIrreducible(zeta) and r eq g : "Argument must be a simple ordinary Jacobian.";
    S := EndomorphismRingKnownSubring(J : MaximalRealSubring := MaximalRealSubring);
    K<pi> := NumberField(S);
    R := EquationOrder(K);
    OK := MaximalOrder(K);
    assert zeta eq DefiningPolynomial(K);
    // If a global subring is given:
    if Type(GlobalSubring) eq RngOrd then
	KR := NumberField(GlobalSubring);
	require DefiningPolynomial(KR) eq zeta : 
	    "Parameter \"GlobalSubring\" must be an order in the number field with defining polynomial ", zeta;
	m := hom< KR->K | K.1 >;
	GlobalSubring := sub< MaximalOrder(S) | [ m(x) : x in Basis(GlobalSubring) ] >;
	S := sub< OK | Basis(S) cat Basis(GlobalSubring) >;
	J`EndomorphismRingKnownSubring := S;
	J`KnownSubringConductorAbelianInvariants := ConductorAbelianInvariants(S);
    end if;
    // 
    ZZ := IntegerRing();
    PZ := PolynomialRing(ZZ);
    // Determine a basis of generators for the effective subring Z[pi].
    M := Matrix(ZZ,[ Eltseq(OK!x) : x in Basis(R) ]);
    A := FreeAbelianGroup(deg);
    B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
    expR := Exponent(B);
    vprint EndomorphismRing : "  Frobenius:", zeta;
    vprint EndomorphismRing :
        "  Frobenius conductor abelian invariants:", AbelianInvariants(B);
    gens := [ g : g in Generators(B) ];
    ords := [ Order(g) : g in gens ];
    fncs := [ ords[i]*K!OK!Eltseq(gens[i]@@m) : i in [1..#gens] ];
    fncs := [ PZ | ChangeUniverse(Eltseq(f),ZZ) : f in fncs ];
    // New enlarge to the known subring.
    MS := Matrix(ZZ,[ Eltseq(OK!x) : x in Basis(S) ]);
    BS, mS := quo< A | [ A!Eltseq(MS[i]) : i in [1..deg] ] >;
    expS := Exponent(BS);
    vprint EndomorphismRing :
        "  Conductor abelian invariants of known subring:", AbelianInvariants(B);
    if not assigned J`EndomorphismRingLocalRings then
	J`EndomorphismRingLocalRings := AssociativeArray(IntegerRing());
    end if;
    for l in PrimeDivisors(expS) do
	vprint EndomorphismRing : "  l =", l;
	// First determine if the function input specifies the local endomorphism
	// ring, and if so cache this on the Jacobian:
	if IsDefined(LocalRings,l) then
	    Kl := NumberField(LocalRings[l]);
	    require DefiningPolynomial(Kl) eq zeta : 
		"Parameter \"LocalRings\" must be orders in the number field with defining polynomial ", zeta;
	    m := hom< Kl->K | K.1 >;
	    J`EndomorphismRingLocalRings[l] := sub< OK | [ m(x) : x in Basis(LocalRings[l]) ] >;
	end if;
	// Now determine if the Jacobian knows its local endomorphism ring:
	if IsDefined(J`EndomorphismRingLocalRings,l) then
	    R := J`EndomorphismRingLocalRings[l] meet sub< OK | Basis(pMaximalOrder(S,l)) >;
	    S := sub< OK | Basis(S) cat Basis(R) >;
	    M := Matrix(ZZ,[ Eltseq(OK!x) : x in Basis(S) ]);
	    B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
	    vprint EndomorphismRing : "New Abelian invariants:", AbelianInvariants(B);
	    continue;
	end if;
        if l eq p then
	    nl := Valuation(expR,l);
	    for k in [1..nl] do
                vprintf EndomorphismRing : "  k = %o <= %o\n", k, nl;
                LL, s := MaximalOrderTorsionSplittingField(zeta,l,k);
                vprint EndomorphismRing : "  Splitting degree:", Degree(LL);
                JL := BaseChange(J,LL);
                Gl, ii := TorsionSubgroup(JL,l^k);
                if Ngens(Gl) ne g or &or[ Order(g) ne l^k : g in Generators(Gl) ] then
                    vprintf EndomorphismRing :
                        "  %o^%o-torsion is not full, breaking\n", l, k;
                    break k;
                end if;
                Jl := [ ii(g) : g in Generators(Gl) ];
                for i in [1..#gens] do
                    if ords[i] mod l^k eq 0 then
                        zero := true;
                        for P in Jl do
                            Q := FrobeniusApplication(fncs[i],P,FF);
                            if Q ne Parent(Q)!0 then
                                zero := false;
                                vprintf EndomorphismRing :
                                    "Nonzero image on %o mod %o [breaking k = %o]\n", fncs[i], l^k, k;
                            end if;
                        end for;
                        if zero then
                            vprint EndomorphismRing : "Extending endomorphism ring...";
                            qi := q/pi;
                            m := Ceiling(k/Degree(FF));
                            S := sub< OK | Basis(S),
                                Evaluate(fncs[i],pi)/l^k,
                                Evaluate(fncs[i],qi)*qi^m/l^k >;
                            M := Matrix(ZZ,[ Eltseq(OK!x) : x in Basis(S) ]);
                            B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
                            vprint EndomorphismRing :
                                "New Abelian invariants:", AbelianInvariants(B);
                            if Valuation(#B,l) eq 0 then
				vprintf EndomorphismRing :
				    "Maximal endomorphism ring at l = %o, breaking.\n", l;
                                break k;
                            end if;
                        end if;
                    end if;
                end for;
            end for;
        elif l ne p then
            if Valuation(Order(B),l) eq 1 and Discriminant(OK) mod l ne 0 then
                // This prime is likely a larger one which needs to be treated
                // more carefully.
                vprint EndomorphismRing : "  Treating multiplicity one prime l = ", l;
                PF := PolynomialRing(GF(l)); x := PF.1;
                rts := Roots(PF!zeta);
                assert #[ r[1] : r in rts | r[2] gt 1 ] eq 1; // Disc(OK) != 0 mod l used here
                assert #[ r[1] : r in rts | r[2] eq 2 ] eq 1;
                c := [ r[1] : r in rts | r[2] gt 1 ][1];
                k := Order(c);
                g1 := PF!zeta div (x-c)^2;
                /*
                The generic case is that zeta(x) = (x-c)^2*g(x) mod l and 
                that the k-th power of Frobenius does not split further, 
                i.e. we have zeta_k(x) = (x-1)^2*h(x) where h(x) is either
                irreducible or otherwise does not have (x-1) as a factor,
                where zeta_k(x) is the charpoly of the k-th power of Frobenius.
                We will treat this easy case.
                */
                R<xi> := quo< PF | g1 >;
                gk := MinimalPolynomial(xi^k);
                if Evaluate(gk,1) ne 0 then
                    LL := FiniteField(p,k*Degree(FF)); Embed(FF,LL);
                    vprint EndomorphismRing : "  Splitting degree for (Z/lZ)^2:", Degree(LL);
                    G1, i1 := TorsionSubgroup(BaseChange(J,LL),l);
                    I1 := AbelianInvariants(G1);
                    vprint EndomorphismRing : "  Torsion invariants [l^1]:", AbelianInvariants(G1);
                    G2, i2 := TorsionSubgroup(BaseChange(J,LL),l^2);
                    I2 := AbelianInvariants(G2);
                    vprint EndomorphismRing : "  Torsion invariants [l^2]:", AbelianInvariants(G2);
                    if I1 eq [l,l] then
                        // End(J) is maximal at l.
                        f1 := PZ!ChangeUniverse(Eltseq(g1),ZZ);
                        gen := (pi-ZZ!c)*Evaluate(f1,pi);
                        vprint EndomorphismRing : "Extending endomorphism ring...";
                        S := sub< OK | Basis(S), gen/l >;
                        M := Matrix(ZZ,[ Eltseq(OK!x) : x in Basis(S) ]);
                        B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
                        vprint EndomorphismRing :
                            "New Abelian invariants:", AbelianInvariants(B);
                    elif I1 eq [l] and I2 eq [l^2] then
                        // End(J) is nonmaximal at l.
                        continue;
                    else
                        // This shouldn't happen since gk(1) != 1.
                        assert false;
                    end if;
                    // Fall back to the usual calculation -- the full l-torsion
                    // splits over a smaller field so this is not so bad.
                    vprint EndomorphismRing : "  Fall back to full l-torsion computation.";
                end if;
            end if;
            max_val := Valuation(expR,l);
            for k in [1..max_val] do
                vprint EndomorphismRing : "  k =", k;
                LL, s := MaximalOrderTorsionSplittingField(zeta,l,k);
                vprint EndomorphismRing : "  Splitting degree:", Degree(LL);
                Gl, ii := TorsionSubgroup(BaseChange(J,LL),l^k);
                vprint EndomorphismRing : "  Torsion invariants:", AbelianInvariants(Gl);
                while Ngens(Gl) ne 2*g or &or[ Order(g) ne l^k : g in Generators(Gl) ] do
                    /*
                    if k eq max_val then
                        vprintf EndomorphismRing : "  %o^%o-torsion is not full, breaking\n", l, k;
                        break k;
                    end if;
                    */
                    vprintf EndomorphismRing : "  %o^%o-torsion is not full (= %o), extending base\n", l, k, AbelianInvariants(Gl);
		    LL_new := FiniteField(p,l*Degree(LL));
		    Embed(LL,LL_new); LL := LL_new;
                    vprint EndomorphismRing : "  New splitting degree:", Degree(LL);
                    Gl, ii := TorsionSubgroup(BaseChange(J,LL),l^k);
                end while;
                Jl := [ ii(g) : g in Generators(Gl) ];
                for i in [1..#gens] do
                    if ords[i] mod l^k eq 0 then
                        zero := true;
                        for P in Jl do
                            Q := FrobeniusApplication(fncs[i],P,FF);
                            if Q ne Parent(Q)!0 then
                                zero := false;
                                vprintf EndomorphismRing :
                                    "Nonzero image on %o mod %o [breaking k = %o]\n", fncs[i], l^k, k;
                            end if;
                        end for;
                        if zero then
                            vprint EndomorphismRing : "Extending endomorphism ring...";
                            S := sub< OK | Basis(S), Evaluate(fncs[i],pi)/l^k >;
                            M := Matrix(Integers(),[ Eltseq(OK!x) : x in Basis(S) ]);
                            B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
                            vprint EndomorphismRing :
                                "New Abelian invariants:", AbelianInvariants(B);
                            if Valuation(#B,l) eq 0 then
				vprintf EndomorphismRing :
				    "Maximal endomorphism ring at l = %o, breaking.\n", l;
                                break k;
                            end if;
                        end if;
                    end if;
                end for;
            end for;
        end if;
    end for;
    M := Matrix(Integers(),[ Eltseq(OK!x) : x in Basis(S) ]);
    B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
    cond := AbelianInvariants(B);
    vprint EndomorphismRing : "Returning conductor Abelian invariants:", cond;
    J`EndomorphismRing := S;
    J`ConductorAbelianInvariants := cond;
    return S, cond;
end intrinsic;

//////////////////////////////////////////////////////////////////////////////
// Maximal endomorphism ring testing algorithm
//////////////////////////////////////////////////////////////////////////////

intrinsic HasMaximalEndomorphismRing(
    J::JacHyp[FldFin] : MaximalRealSubring := false) -> RngOrd, SeqEnum
    {Given a simple and ordinary Jacobian J, returns true if and only if the
    endomorphism ring is the maximal order.}

    if assigned J`EndomorphismRing then
        return IsMaximal(J`EndomorphismRing);
    end if;
    FF := BaseRing(J);
    g := Dimension(J);
    q := #FF;
    p := Characteristic(FF);
    zeta := FrobeniusCharacteristicPolynomial(J);
    r := Max([ i : i in [0..g] | Coefficient(zeta,2*g-i) mod p ne 0 ]);
    require IsIrreducible(zeta) and r eq g : 
        "Argument must be a simple ordinary Jacobian.";
    S := EndomorphismRingKnownSubring(J : MaximalRealSubring := MaximalRealSubring);
    if IsMaximal(S) then return true; end if;
    deg := 2*g;
    K<pi> := NumberField(S);
    O := MaximalOrder(K);
    R := EquationOrder(K);
    zeta := FrobeniusCharacteristicPolynomial(J);
    assert zeta eq DefiningPolynomial(K);
    // 
    ZZ := IntegerRing();
    PZ := PolynomialRing(ZZ);
    // Determine a basis of generators for the effective subring Z[pi].
    M := Matrix(ZZ,[ Eltseq(O!x) : x in Basis(R) ]);
    A := FreeAbelianGroup(deg);
    B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
    exp := Exponent(B);
    vprint EndomorphismRing : "  Frobenius:", zeta;
    vprint EndomorphismRing : "  Frobenius conductor abelian invariants:", AbelianInvariants(B);
    // Now enlarge B to the known subring.
    M := Matrix(ZZ,[ Eltseq(O!x) : x in Basis(S) ]);
    B, m := quo< A | [ A!Eltseq(M[i]) : i in [1..deg] ] >;
    exp := Exponent(B);
    vprint EndomorphismRing : "  Conductor abelian invariants of known subring:", AbelianInvariants(B);
    if exp eq 1 then return true; end if;
    for l in PrimeDivisors(exp) do
        vprint EndomorphismRing : "  l =", l;
	for k in [1..Valuation(exp,l)] do
	    vprint EndomorphismRing : "  k =", k;
	    LL, s := MaximalOrderTorsionSplittingField(zeta,l,k);
	    vprint EndomorphismRing : "  Splitting degree:", Degree(LL);
	    Gl, ii := TorsionSubgroup(BaseChange(J,LL),l^k);
	    rnkl := l eq p select g else 2*g; 
	    if Ngens(Gl) ne rnkl or &or[ Order(g) ne l^k : g in Generators(Gl) ] then
		vprintf EndomorphismRing : "  %o^%o-torsion is not full, breaking\n", l, k;
		return false;
	    end if;
	end for;
    end for;
    O := EndomorphismRing(J);
    return IsMaximal(O);
end intrinsic;
