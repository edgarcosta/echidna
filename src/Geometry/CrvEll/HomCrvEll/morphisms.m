////////////////////////////////////////////////////////////////////////
//                                                                    //
//                      Elliptic Curve Morphisms                      //
//                            David Kohel                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Attribute declarations                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

declare attributes CrvEll:
    EndomorphismRing;

declare type HomCrvEll[MapCrvEll];

declare attributes HomCrvEll:
    Domain,    // Make domain and codomain sequences only --
    Codomain,  //    use the global mechanism to recover curves.
    Rank,
    GeneratorLabels, // endomorphism, when a ring
    BasisMorphisms, // Currently these are implemented as hom's
    // but later should be a sequence of rational maps.
    // These must be designed to avoid circular references.
    // Attributes of endomorphisms rings:
    // Since there is not special type (rejected EndCrvGrp) for
    // endomorphism rings, we have the following attributes.
    IsRing, // Rather than testing Domain and Codomain?
    Ring,   // The ring (integers, or quadratic or quaternion order).
    IsFull, // Full endomorphism ring or subring generated by Frobenius?
    Frobenius; // The coordinates of the Frobenius endomorphism

declare attributes MapCrvEll:
    Parent,
    Degree,
    Coordinates,   // Coordinates in the abstract ring
    RationalMaps;  // Sequence of tuples <phi,omg,psi> of polynomials
// or functions defining the factored isogeny
// A Frobenius map has the special form <1,1,1>, and the identity
// map has the form <0,1,1>.  The polynomials may be stored as
//        < <0,phi(x)>, <0/1,omg0(x)>, <0/1,psi0(x)> >
// where 0/1 indicates whether 2*y+a1*x+a3 is a factor, and
// omg0(x) or psi0(x) is the cofactor in omg(x,y) or psi(x,y).
// If necessary, there may be a special type or record for such
// primitive isogenies, in which case the internal datatype can
// be modified as necessary.

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Creation Functions                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic Aut(E::CrvEll) -> GrpPerm, Map
    {The automorphism group of E.}
    return AutomorphismGroup(E);
end intrinsic;

/*
intrinsic AutomorphismGroup(E::CrvEll) -> GrpPerm, Map
    {The automorphism group of E.}
    R := End(E);
    k := BaseRing(E);
    j := jInvariant(E);
    if j ne 0 and j ne 12^3 then
	G := SymmetricGroup(2);
	return G, map< G -> R | x :-> R!(-1)^Eltseq(x)[2] >;
    elif j eq 0 then
	p := Characteristic(k);
	if p notin {2,3} then
	    rts := Roots(X^2+X+1) where X is PolynomialRing(k).1;
	    if #rts eq 0 then
		G := SymmetricGroup(2);
		return G, map< G -> R | x :-> R!(-1)^Eltseq(x)[2] >;
	    else
		w := rts[1][1];
		a1, a2 := Explode(Eltseq(E));
		R := CoordinateRing(AffinePatch(E,1));
		x := R.1; y := R.2;
		t := R![1,w*(x+(a1^2+4*a2)/6),-y];
		G := sub< SymmetricGroup(6) | [2,3,4,5,6,1] >;
		return G, map< G -> R | x :-> t^(Eltseq(x)[1]-1) >;
	    end if;
	elif p eq 2 then
	    R := End(E);
	    t := TraceOfFrobenius(E);
	    q := #k;
	    if t eq 0 then
		if Valuation(q,p) mod 2 eq 1 then 
		    // DK := -8
		    G := SymmetricGroup(2);
		    return G, map< G->R |
			[ car< G, R > | <G!1,R!1>, <G.1,R!-1> ] >;
		else 
		    // DK := -4
		    // BasisInitialize(R);
		    T := PolynomialRing(k).1;  
		    P := CoordinateRing(AmbientSpace(AffinePatch(E,1)));
		    x := P.1; y := P.2;
		    _, a2, a3, a4, a6 := Explode(Eltseq(E));
		    _, s := IsPower(a3,3); 
		    r := s^2;
		    t := Roots(T^2 + a3*T + r^3 + a2*r^2 + a4*r + a6)[1][1];  
		    iE := R![1,x+r,y+s*x+t];
		    R`Ring := EquationOrder(T^2+1) where 
			T is PolynomialRing(Integers()).1;
		    iE`Coordinates := [0,1];
		    G := sub< SymmetricGroup(4) | [2,3,4,1] >;
		    return G, map< G->R | [ car< G, R > |
			<G!1,R!1>, <G.1,R.1>, <G.1^2,R.1^2>, <G.1^3,-R.1> ] >; 
		end if;
	    elif t^2 eq q then
		// DK := -3
		// BasisInitialize(R);
		assert false;
	    elif t^2 eq 2*q then
		// DK := -4
		// BasisInitialize(R);
		assert false;
	    elif t^2 eq 4*q then
		// DK := 0
		// SupersingularInitialize(R);
		G := sub< SymmetricGroup(8) | 
		    (1, 2, 3)(5, 6, 7),
		    (4, 1, 3, 6)(2, 5, 7, 8) >;
		error if true, "Not implemented error.";
	    end if;
	    return G, _;
	else // p eq 3 
	    assert p eq 3;
	    R := End(E);
	    // SupersingularInitialize(R);
	    G := SymmetricGroup(3);
	    return G, _;
	end if;
    elif j eq 12^3 then
	rts := Roots(X^2+1) where X is PolynomialRing(k).1;
	print "HERE";
	print "R =", R;
	if #rts eq 0 then
	    G := SymmetricGroup(2);
	    return G, map< G -> R | x :-> R!(-1)^Eltseq(x)[2] >;
	else
	    i := rts[1][1];
	    G := sub< SymmetricGroup(4) | [2,3,4,1] >;
	    K := FunctionField(E);
	    a1, a2, a3 := Explode(Eltseq(E));
	    x := K!BaseField(K).1; y := K.1; 
	    t := R![1,-x-(a1^2+4*a2)/6,-i*y+(i-1)*(a1*x+a3)/2];
	    return G, map< G -> R | x :-> t^(Eltseq(x)[1]-1) >;
	end if;
    end if;
end intrinsic;
*/

intrinsic End(E::CrvEll) -> HomCrvEll
    {The endomophism ring of E.}
    return EndomorphismRing(E);
end intrinsic;

intrinsic EndomorphismRing(E::CrvEll) -> HomCrvEll
    {The endomophism ring of E.}
    if assigned E`EndomorphismRing then
	return E`EndomorphismRing;
    end if;
    R := New(HomCrvEll);
    R`Domain := E;
    R`Codomain := E;
    R`IsFull := true;
    k := BaseRing(E);
    if Category(k) eq FldFin then
	j := jInvariant(E);
	p := Characteristic(k);
	if j eq 0 then
	    if IsSupersingular(E) then
		if Rank(R) eq 2 then
		    T := PolynomialRing(Integers()).1;
		    if p eq 2 then
			t := Trace(E); q := #k;
			case t^2 :
			when 0 :
			    if Valuation(q,2) mod 2 eq 1 then
				R`Ring := EquationOrder(T^2+2);
			    else
				R`Ring := EquationOrder(T^2+1);
			    end if;
			when q :
			    R`Ring := EquationOrder(T^2+T+1);
			when 2*q :
			    R`Ring := EquationOrder(T^2+1);
			end case;
		    elif p mod 4 eq 3 then
			case #TwoTorsionSubgroup(E) :
			    when 2 : R`Ring := EquationOrder(T^2+p);
			else R`Ring := EquationOrder(T^2+T+((p-1) div 2));
			end case;
		    else // p mod 4 eq 1 then
			R`Ring := EquationOrder(T^2+p);
		    end if;
		else
		    if p eq 3 then R`Ring := QuaternionOrder(-3,-4,0);
		    else R`Ring := QuaternionOrder(-3,-4*(p+1) div 3,2);
		    end if;
		end if;
	    else
		T := PolynomialRing(Integers()).1;
		R`Ring := EquationOrder(T^2+3);
	    end if;
	elif j eq 12^3 then
	    // p = 2 and p = 3 caught with j = 0, need only
	    // treat rank 2 vs rank 4 cases.
	    if Rank(R) eq 2 then
		T := PolynomialRing(Integers()).1;
		R`Ring := EquationOrder(T^2+1);
	    elif Rank(R) eq 4 then
		if p eq 2 then R`Ring := QuaternionOrder(-4,-p,0);
		else R`Ring := QuaternionOrder(-4,-(p+1),2);
		end if;
	    end if;
	end if;
    end if;
    E`EndomorphismRing := R;
    return R;
end intrinsic;

intrinsic Hom(E::CrvEll,F::CrvEll) -> HomCrvEll
    {The module of homomorphisms E -> F.}
    require BaseRing(E) cmpeq BaseRing(F) :
	"Arguments must be defined over the same ring";
    H := New(HomCrvEll);
    H`Domain := E;
    H`Codomain := F;
    return H;
end intrinsic;

intrinsic IsCoercible(H::HomCrvEll,S::.) -> MapCrvEll
    {}
    if Category(S) eq MapCrvEll and Parent(S) eq H then
	return true, S;
    elif Category(S) eq RngIntElt then
	if S eq 0 then
	    f := New(MapCrvEll);
	    f`Parent := H;
	    f`Coordinates := [ 0 : k in [1..Rank(H)] ];
	    f`RationalMaps := [ 1, 0, 1, 1 ];
	    return true, f;
	elif Codomain(H) eq Domain(H) then
	    f := New(MapCrvEll);
	    f`Parent := H;
	    f`Coordinates := [S] cat [ 0 : k in [2..Rank(H)] ];
	    return true, f;
	end if;
    elif Category(S) eq SeqEnum then
	if Category(Universe(S)) eq FldRat then
	    bool, S := CanChangeUniverse(S,Integers());
	    if not bool then return false, _; end if;
	end if;
	if Category(Universe(S)) eq RngMPol then
	    P := Universe(S);
	    require #S eq 3 and Rank(P) eq 2 :
		"Morphism must be defined by three " *
		"defining polynomials in two variables.";
	    E := Domain(H);
	    psi1 := S[1];
            psi0 := GCD(psi1,psi2)
                where psi2 := P!Evaluate(DivisionPolynomial(E,2),P.1);
            f := New(MapCrvEll);
	    f`Parent := H;
	    f`RationalMaps := S cat [psi0];
	    f`Degree := 2*Degree(psi1,1)-Degree(psi0,1)+1;
	    return true, f;
	elif Category(Universe(S)) eq RngInt then
	    if #S ne Rank(H) then
		return false, "Morphism must be defined by " *
		    Sprint(Rank(H)) * " sequence coordinates";
	    end if;
	    f := New(MapCrvEll);
	    f`Parent := H;
	    f`Coordinates := S;
	    return true, f;
	end if;
    end if;
    return false, "Invalid coercion";
end intrinsic;

intrinsic Identity(H::HomCrvEll) -> MapCrvEll
    {The identity endomorphism of C.}
    require H`Domain eq H`Codomain :
	"Argument must be a ring of endomorphisms.";
    return H!1;
end intrinsic;

intrinsic FrobeniusEndomorphism(R::HomCrvEll) -> MapCrvEll
    {}
    E := Domain(R);
    require E eq Codomain(R) :
	"Argument must be the endomorphism ring of an elliptic curve";
    require Category(BaseRing(E)) eq FldFin :
	"Domain of argument must be defined over a finite field";
    return R!R`Frobenius;;
end intrinsic;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             Printing                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic Print(H::HomCrvEll, level::MonStgElt)
    {}
    C := H`Domain;
    D := H`Codomain;
    if C eq D then
	printf "Endomomorphism ring of %o", C;
    else
	printf "Module of homomorphisms from:\n%o\nto:\n%o", C, D;
    end if;
end intrinsic;

intrinsic AssignNames(~H::HomCrvEll, S::[MonStgElt])
    {Assign names to generating elements.}
    n := Rank(H);
    if Domain(H) eq Codomain(H) then
	S := [ "" ] cat S;
    end if;
    require #S eq n: "Argument 2 must have length", n;
    H`GeneratorLabels := S;
end intrinsic;

intrinsic Name(H::HomCrvEll,i::RngIntElt) -> MapCrvEll
    {The ith generator.}
    require 1 le i : "Invalid index";
    if Domain(H) eq Codomain(H) then i +:= 1; end if;
    require i le Rank(H) : "Invalid index";
    return H!([ 0 :k in [1..i-1] ] cat [1] cat [ 0 : k in [i+1..Rank(H)]]);
end intrinsic;

intrinsic '.'(H::HomCrvEll,i::RngIntElt) -> MapCrvEll
    {The ith generator.}
    require 1 le i : "Invalid index";
    if Domain(H) eq Codomain(H) then i +:= 1; end if;
    require i le Rank(H) : "Invalid index";
    return H!([ 0 :k in [1..i-1] ] cat [1] cat [ 0 : k in [i+1..Rank(H)]]);
end intrinsic;

function GeneratorLabels(H)
    if not assigned H`GeneratorLabels then
	if Domain(H) eq Codomain(H) then
	    H`GeneratorLabels := [ "" ] cat
		[ "$." * IntegerToString(k) : k in [1..Rank(H)-1] ];
	else
	    H`GeneratorLabels := [ "$." * IntegerToString(k) : k in [1..Rank(H)] ];
	end if;
    end if;
    return H`GeneratorLabels;
end function;

intrinsic Print(f::MapCrvEll, level::MonStgElt)
    {}
    if assigned f`Coordinates then
	C := f`Coordinates;
	if &and[ c eq 0 : c in C[2..#C] ] then
	    printf "[%o]", C[1];
	else
	    X := GeneratorLabels(Parent(f));
	    plus := "";
	    for k in [1..#C] do
		if C[k] ne 0 then
		    if C[k] lt 0 and plus ne "" then
			C[k] *:= -1;
			if plus eq "" then
			    plus := "- ";
			else
			    plus := " - ";
			end if;
		    end if;
		    if X[k] eq "" or C[k] ne 1 then
			printf "%o[%o]", plus, C[k];
			if X[k] ne "" then
			    printf "*%o", X[k];
			end if;
		    else
			printf "%o%o", plus, X[k];
		    end if;
		    plus := " + ";
		end if;
	    end for;
	end if;
    end if;
    if level eq "Maximal" or not assigned f`Coordinates then
	S := f`RationalMaps;
	R := CoordinateRing(Ambient(Domain(Parent(f))));
	X := R.1; Y := R.2; Z := R.3;
	printf "(%o : %o : %o) :-> ", X, Y, Z;
	psi := Homogenization(Evaluate(S[1],[X,Y]),Z);
	phi := Homogenization(Evaluate(S[2],[X,Y]),Z);
	omg := Homogenization(Evaluate(S[3],[X,Y]),Z);
	if Degree(f) mod 2 eq 1 then
	    printf "((%o)*(%o) : %o : (%o)^3)",	phi, psi, omg, psi;
	else
	    if Degree(f) eq 2 or S[1] eq S[4] then
		printf "((%o)*(%o) : %o : (%o)^2)", phi, psi, omg, psi;
	    else
		psi2 := Homogenization(Evaluate(S[4],[X,Y]),Z);
		psi1 := psi div psi2;
		printf "((%o)*(%o) : %o : (%o)^3*(%o)^2)",
		    phi, psi, omg, psi1, psi2;
	    end if;
	end if;
    end if;
end intrinsic;

intrinsic 'eq'(H::HomCrvEll,I::HomCrvEll) -> BoolElt
    {}
    return Domain(H) cmpeq Domain(I) and
	Codomain(H) cmpeq Codomain(I);
end intrinsic;

intrinsic 'eq'(f::MapCrvEll,g::MapCrvEll) -> BoolElt
    {}
    if Parent(f) ne Parent(g) then return false; end if;
    if assigned f`Coordinates and assigned g`Coordinates then
	return Coordinates(f) eq Coordinates(g);
    end if;
    return f`RationalMaps eq g`RationalMaps;
end intrinsic;

intrinsic 'in'(f::., M::HomCrvEll) -> BoolElt
    {Returns true if f is in M.}
    if Type(f) ne MapCrvEll then return false; end if;
    return Parent(f) eq M;
end intrinsic;

intrinsic Parent(f::MapCrvEll) -> HomCrvEll
    {The parent of f.}
    return f`Parent;
end intrinsic;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         Access Functions                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic Domain(H::HomCrvEll) -> CrvEll
    {The domain of f.}
    return H`Domain;
end intrinsic;

intrinsic Codomain(H::HomCrvEll) -> CrvEll
    {The codomain of f.}
    return H`Codomain;
end intrinsic;

intrinsic Domain(f::MapCrvEll) -> CrvEll
    {The domain of f.}
    return (f`Parent)`Domain;
end intrinsic;

intrinsic Codomain(f::MapCrvEll) -> CrvEll
    {The codomain of f.}
    return (f`Parent)`Codomain;
end intrinsic;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   Attributes and Functionality                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

function EndoDepth(E,p,r)
    // PRE: E is an elliptic curve, p a prime dividing the conductor 
    // of the ring generated by Frobenius, and r is the maximum 
    // depth of E (:= valuation of the conductor of End(E) at p).
    // POST: Returns the depth t of E (0 <= t <= r).
    X0 := ModularCurveX0(p);
    S := ModuliPoints(X0,E);
    inv := CanonicalInvolution(X0);
    if #S eq 1 then
	return r;
    else
	Chain1 := S[[1]]; Chain2 := S[[2]];
	for k in [1..r-1] do
	    F := Codomain(Isogeny(E,Chain1[k]));
	    S := ModuliPoints(X0,F);
	    if #S eq 1 then return r-k; end if;
	    Append(~Chain1,Exclude(S,inv(Chain1[k]))[1]);
	    F := Codomain(Isogeny(E,Chain2[k]));
	    S := ModuliPoints(X0,F);
	    if #S eq 1 then return r-k; end if;
	    Append(~Chain2,Exclude(S,inv(Chain2[k]))[1]);
	end for;
    end if;
    return 0;
end function;

function RingStructure(R)
    // PRE: R is the endomorphism ring of an ordinary elliptic curve
    // over a finite field.
    // POST: Returns the quadratic ring structure, plus the Frobenius
    // endomorphism as coordinates in the ring.

    PZ := PolynomialRing(Integers()); X := PZ.1;
    E := Domain(R);
    t := TraceOfFrobenius(E);
    q := #BaseRing(E);
    D := t^2 - 4*q;
    DK := FundamentalDiscriminant(D);
    m := Isqrt(D div DK);
    a := t div 2;
    f0 := X^2 - (t-2*a)*X + (a^2-t*a+q);
    S0 := EquationOrder(f0);
    x := S0![0,1];
    pi := a + x;
    B := Basis(S0);
    for p in PrimeDivisors(m) do
	r := Valuation(m,p);
	t := EndoDepth(E,p,r);
	if t lt r then
	    PR := PolynomialRing(ResidueClassRing(p^r));
	    f1 := GCD(PR!f0,Derivative(PR!f0));
	    Append(~B,Evaluate(PZ!f1,x)/p^(r-t));
	end if;
    end for;
    return S1, Eltseq(S1!pi) where S1 is Order(B);
end function;

intrinsic Ring(R::HomCrvEll) -> Rng
    {}
    require Domain(R) eq Codomain(R) : "Argument must be an endomophism ring";
    if not assigned R`Ring then
	r := Rank(R);
	if r eq 1 then
	    R`Ring := Integers();
	elif Category(BaseRing(Domain(R))) eq FldFin and r eq 2 then
	    R`Ring, R`Frobenius := RingStructure(R);
	else
	    require false : "Giving up.";
	end if;
    end if;
    return R`Ring, hom< R`Ring -> R | x :-> R!Eltseq(x) >;
end intrinsic;

function BasisMorphism(M,k)
    if not assigned M`BasisMorphisms then
	E := Domain(M);
	if E eq Codomain(M) and Rank(M) eq 2 then
	    K := BaseRing(E);
	    error if Category(K) ne FldFin, "Basis morphisms unknown";
	    q := #K;
	    M`BasisMorphisms := [
		hom< E -> E | P :-> P >,
	        hom< E -> E | P :-> E![ a^q : a in Eltseq(P) ] > ];
	else
	    error if true, "Basis morphisms not computed";
	end if;
    end if;
    return M`BasisMorphisms[k];
end function;

intrinsic Coordinates(f::MapCrvEll) -> SeqEnum
    {}
    return f`Coordinates;
end intrinsic;

intrinsic ElementToSequence(f::MapCrvEll) -> SeqEnum
    {}
    return f`Coordinates;
end intrinsic;

intrinsic Trace(f::MapCrvEll) -> RngIntElt
    {}
    require Domain(f) eq Codomain(f) :
	"Argument must be an endomorphism";
    return Trace(Ring(Parent(f))!f`Coordinates);
end intrinsic;

intrinsic Degree(f::MapCrvEll) -> RngIntElt
    {}
    if assigned f`Degree then return f`Degree; end if;
    return Norm(Ring(Parent(f))!f`Coordinates);
end intrinsic;

intrinsic Discriminant(R::HomCrvEll) -> RngIntElt
    {}
    require Domain(R) eq Codomain(R) : "Argument must be an endomorphism ring.";
    if Rank(R) eq 1 then return 1; end if;
    return Discriminant(Ring(R));
end intrinsic;

intrinsic Rank(H::HomCrvEll) -> RngIntElt
    {}
    E := Domain(H);
    F := Codomain(H);
    require Category(E) eq CrvEll and Category(F) eq CrvEll :
	"Argument must be module of morphisms of elliptic curves.";
    K := BaseRing(E);
    if not assigned H`Rank then
	if Category(K) eq FldFin then
	    t1 := TraceOfFrobenius(E);
	    t2 := TraceOfFrobenius(F);
	    if t1 ne t2 then
		H`Rank := 0;
	    elif t1 mod Characteristic(K) ne 0 or t1^2 ne 4*#K then
		H`Rank := 2;
	    else
		H`Rank := 4;
	    end if;
	elif Category(K) eq FldRat then
	    H`Rank := 1;
	else
	    require false :
		"Coeffficient ring of domain must be a finite field or the rationals.";
	    // if IsCMEllipticCurve...
	    H`Rank := 1;
	end if;
    end if;
    return H`Rank;
end intrinsic;

function BasisMorphism(M,k)
    if not assigned M`BasisMorphisms then
	E := Domain(M);
	if E eq Codomain(M) and Rank(M) eq 2 then
	    K := BaseRing(E);
	    error if Category(K) ne FldFin, "Basis morphisms unknown";
		q := #K;
		M`BasisMorphisms := [ hom< E -> E | P :-> P >,
		hom< E -> E | P :-> E![ a^q : a in Eltseq(P) ] > ];
	    else
		error if true, "Basis morphisms not computed";
		end if;
	    end if;
	    return M`BasisMorphisms[k];
	end function;

intrinsic Basis(H::HomCrvEll) -> SeqEnum
    {}
    E := Domain(H);
    F := Codomain(H);
    require Category(E) eq CrvEll and Category(F) eq CrvEll :
	"Argument must be module of morphisms of elliptic curves.";
    K := BaseRing(E);
    return [ H!( [ 0 : k in [1..i-1] ] cat [1] cat
	[ 0 : k in [i+1..Rank(H)] ] ) : i in [1..Rank(H)] ];
end intrinsic;

intrinsic IsIsomorphicDRK(E::CrvEll,F::CrvEll) -> BoolElt, MapCrvEll
    {Return true and an isomorphism if E is isomorphic to F.}
    if E eq F then
	return true, Identity(End(E));
    end if;
    val, f := IsIsomorphic(E,F);
    if val then
	r, s, t, u := Explode(IsomorphismData(f));
	P := CoordinateRing(AmbientSpace(F));
	x := P.1; y := P.2; z := P.3;
	return true, Hom(E,F)![u^2*x+r*z,u^3*y+s*x+t*z,z];
    end if;
    return false;
end intrinsic;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                      Arithmetic of Morphisms                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic CharacteristicPolynomial(x::MapCrvEll) -> RngUPolElt
    {}
    require Domain(x) eq Codomain(x) :
	"Argument must be an endomorphism";
    return CharacteristicPolynomial(Ring(Parent(x))!x`Coordinates);
end intrinsic;

intrinsic MinimalPolynomial(x::MapCrvEll) -> RngUPolElt
    {}
    require Domain(x) eq Codomain(x) : 
	"Argument must be an endomorphism";
    return MinimalPolynomial(Ring(Parent(x))!x`Coordinates);
end intrinsic;

intrinsic DefiningPolynomials(f::MapCrvEll) -> SeqEnum
    {}
    if assigned f`RationalMaps then
	return [ c : c in f`RationalMaps ];
    end if;
    require false :
	"Argument has no defining polynomials assigned (not implemented).";
end intrinsic;

intrinsic SchemeMorphism(f::MapCrvEll) -> MapSch
    {}
    E1 := Domain(f);
    E2 := Codomain(f);
    P2 := AmbientSpace(E1);
    X := P2.1; Y := P2.2; Z := P2.3;
    psi, phi, omg, psi2 := Explode(f`RationalMaps);
    Psi := Homogenization(Evaluate(psi,[X,Y]),Z);
    Phi := Homogenization(Evaluate(phi,[X,Y]),Z);
    Omg := Homogenization(Evaluate(omg,[X,Y]),Z);
    if Degree(f) eq 2 then
	return map< E1->E2 | [ Phi*Psi, Omg, Psi^2 ] >;
    elif Degree(f) mod 2 eq 0 then
	Psi1 := Homogenization(Evaluate(psi div psi2,[X,Y]),Z);
	Psi2 := Homogenization(Evaluate(psi2,[X,Y]),Z);
	return map< E1->E2 | [ Phi*Psi1*Psi2, Omg, Psi1^3*Psi2^2 ] >;
    else
	return map< E1->E2 | [ Phi*Psi, Omg, Psi^3*Z ] >;
    end if;
end intrinsic;

intrinsic Evaluate(f::RngUPolElt,x::MapCrvEll) -> MapCrvEll
    {}
    require Category(BaseRing(Parent(f))) eq RngInt :
	"Argument 1 must be defined over the integers";
    require Domain(x) eq Codomain(x) :
	"Argument 2 must be an endomorphism";
    R := Parent(x);
    return R!Eltseq(Evaluate(f,Ring(R)!x`Coordinates));
end intrinsic;

intrinsic Evaluate(f::MapCrvEll,P::Pt) -> PtEll
    {The image of P under f.}
    E1 := Domain(f)(Ring(Parent(P)));
    E2 := Codomain(f)(Ring(Parent(P)));
    bool, P := IsCoercible(E1,P);
    require bool :
	"Argument 2 must be a point of the domain of argument 1";
    if P eq Domain(f)!0 then return E2!0; end if;
    if f eq Parent(f)!0 then return E2!0; end if;
    if assigned f`Coordinates then
	C := f`Coordinates;
	Q := E2!0;
	for k in [1..#C] do
	    if C[k] ne 0 then
		Q +:= C[k]*BasisMorphism(Parent(f),k)(P);
	    end if;
	end for;
	return Q;
    elif assigned f`RationalMaps then
	x0, y0, z0 := Explode(Eltseq(P));
	psi, phi, omg, psi2 := Explode(f`RationalMaps);
	if z0 eq 0 then return E2!0; end if;
	z1 := Evaluate(psi,[x0,y0]);
	if z1 eq 0 then return E2!0; end if;
	x1 := Evaluate(phi,[x0,y0]);
	y1 := Evaluate(omg,[x0,y0]);
	if Degree(f) eq 2 then
	    return E2![ x1*z1, y1, z1^2 ];
	elif Degree(f) mod 2 eq 0 then
	    psi1 := psi div psi2;
	    z1 := Evaluate(psi1,[x0,y0]);
	    z2 := Evaluate(psi2,[x0,y0]);
	    return z2 eq 0 select E2!0 else E2![ x1*z1*z2, y1, z1^3*z1^2 ];
	else
	    print "[x1,y1,z1] =", [x1,y1,z1];
	    return E2![ x1*z1, y1, z1^3 ];
	end if;
    end if;
    require false : "Unable to determine map";
end intrinsic;

intrinsic '-'(f::MapCrvEll) -> MapCrvEll
    {}
    if assigned f`Coordinates then
	return Parent(f)![ -c : c in Eltseq(f) ];
    end if;
    g := New(MapCrvEll);
    g`Degree := Degree(f);
    g`Parent := Parent(f);
    a1, _, a3 := Explode(Eltseq(Codomain(f)));
    psi, phi, omg, psi2 := Explode(f`RationalMaps);
    minus_omg := a1 eq 0 select -omg else -omg - a1*phi*psi;
    if Degree(f) mod 2 eq 1 then
	if a3 ne 0 then minus_omg -:= a3*psi^3; end if;
    elif Degree(f) eq 2 then
	if a3 ne 0 then minus_omg -:= a3*psi^2;	end if;
    else // General even degree...
	if a3 ne 0 then
	    psi1 := psi div psi2;
	    minus_omg -:= a3*psi1^3*psi2^2;
	end if;
    end if;
    g`RationalMaps := [ psi, phi, minus_omg, psi2 ];
    return g;
end intrinsic;

intrinsic '+'(f::MapCrvEll,g::MapCrvEll) -> MapCrvEll
    {}
    require Parent(f) eq Parent(g) :
	"Arguments must have the same parent";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    S1 := Eltseq(f); S2 := Eltseq(g);
    return Parent(f)![ S1[i]+S2[i] : i in [1..#S1] ];
end intrinsic;

intrinsic '+'(f::MapCrvEll,n::RngIntElt) -> MapCrvEll
    {}
    require Domain(f) eq Codomain(f) :
	"Argument 1 must be an endomorphism";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    S := Eltseq(f); S[1] +:= n;
    return Parent(f)!S;
end intrinsic;

intrinsic '+'(n::RngIntElt,f::MapCrvEll) -> MapCrvEll
    {}
    require Domain(f) eq Codomain(f) :
	"Argument 1 must be an endomorphism";
    S := Eltseq(f); S[1] +:= n;
    return Parent(f)!S;
end intrinsic;

intrinsic '-'(f::MapCrvEll,g::MapCrvEll) -> MapCrvEll
    {}
    require Parent(f) eq Parent(g) :
	"Arguments must have the same parent";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    S1 := Eltseq(f); S2 := Eltseq(g);
    return Parent(f)![ S1[i]-S2[i] : i in [1..#S1] ];
end intrinsic;

intrinsic '-'(f::MapCrvEll,n::RngIntElt) -> MapCrvEll
    {}
    require Domain(f) eq Codomain(f) :
	"Argument 1 must be an endomorphism";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    S := Eltseq(f); S[1] -:= n;
    return Parent(f)!S;
end intrinsic;

intrinsic '-'(n::RngIntElt,f::MapCrvEll) -> MapCrvEll
    {}
    require Domain(f) eq Codomain(f) :
	"Argument 1 must be an endomorphism";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    S := Eltseq(f); S[1] -:= n;
    return Parent(f)![ -c : c in S ];
end intrinsic;

intrinsic '*'(f::MapCrvEll,g::MapCrvEll) -> MapCrvEll
    {}
    R := Parent(f);
    require Codomain(f) eq Domain(g) :
	"Arguments are not compatible for composition";
    require Domain(f) eq Codomain(f) and Domain(g) eq Codomain(g) :
	"Only implemented for endomorphism rings";
    return R!(Ring(R)!Eltseq(f))*(Ring(R)!Eltseq(g));
end intrinsic;

intrinsic '*'(f::MapCrvEll,n::RngIntElt) -> MapCrvEll
    {}
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    return Parent(f)![ n*c : c in Eltseq(f) ];
end intrinsic;

intrinsic '*'(n::RngIntElt,f::MapCrvEll) -> MapCrvEll
    {}
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    return Parent(f)![ n*c : c in Eltseq(f) ];
end intrinsic;

intrinsic '^'(f::MapCrvEll,n::RngIntElt) -> MapCrvEll
    {}
    require Domain(f) eq Codomain(f) :
	"Argument must be an endomorphism.";
    require assigned f`Coordinates :
	"Argument must be defined by coordinates.";
    return R!Eltseq((Ring(R)!Eltseq(f))^n) where R is Parent(f);
end intrinsic;

function RationalMapAdd(E,S1,S2)
    // Input: S1 and S2 defining functions for isogenies:
    //    S1 := [ psi1, phi1, omg1, psi2_1 ]
    //    S2 := [ psi2, phi2, omg2, psi2_2 ]
    // of the same domain and codomain.
    // Output: rational functions for isogeny sum:
    //    S0 := [...]

    a1,a2,a3,a4,a6 := Explode(Eltseq(E));
    psi1, phi1, omg1, psi1_2 := Explode(S1);
    psi2, phi2, omg2, psi2_2 := Explode(S2);
    /*
    FE<a1,a2,a3,a4,a6> := FunctionField(QQ,5);
    F2<x1,x2> := FunctionField(FE,2);
    PR<Y1,Y2> := PolynomialRing(F2,2);
    K2<y1,y2> := quo< P2 |
	Y1^2 + (a1*x1+a3)*Y1 - (x1^3+a2*x1^2+a4*x1+a6),
	Y2^2 + (a1*x2+a3)*Y2 - (x2^3+a2*x2^2+a4*x2+a6) >;
    E := EllipticCurve([K2|a1,a2,a3,a4,a6]);
    P1 := E![x1,y1];
    P2 := E![x2,y2];

    x1-x2;

    -2*y1*y2 + (-a1*x2 - a3)*y1 + (-a1*x1 - a3)*y2 + x1^2*x2 
	+ x1*x2^2 + 2*a2*x1*x2 + a4*x1 + a4*x2 + 2*a6;

    (a1*x1 - a1*x2)*y1*y2 + (-3*x1*x2^2 - 2*a2*x1*x2 - a4*x1 
	- x2^3 + (-a1^2 - 2*a2)*x2^2 + (-2*a1*a3 - 3*a4)*x2 
	- a3^2 - 4*a6)*y1 + (x1^3 + 3*x1^2*x2 + (a1^2 + 2*a2)*x1^2 
	+ 2*a2*x1*x2 + (2*a1*a3 + 3*a4)*x1 + a4*x2 + (a3^2 + 4*a6))*y2 
	+ (-a1*a2 + 3*a3)*x1^2*x2 + (-a1*a4 + a2*a3)*x1^2 
	+ (a1*a2 - 3*a3)*x1*x2^2 + (-3*a1*a6 + a3*a4)*x1 
	+ (a1*a4 - a2*a3)*x2^2 + (3*a1*a6 - a3*a4)*x2;
    */
    return S1;
end function;
